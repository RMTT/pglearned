import json
import logging
from concurrent import futures

import grpc

# Note: These imports assume the protobuf code has been generated.
# Run: python -m grpc_tools.protoc -I../../proto --python_out=./pgl/proto --grpc_python_out=./pgl/proto ../../proto/pgl_rpc.proto
from .proto import pgl_rpc_pb2
from .proto import pgl_rpc_pb2_grpc

from .adapter import PglAdapter

logger = logging.getLogger(__name__)


class PglRemoteAdapter(pgl_rpc_pb2_grpc.PglRemoteServicer):
    """
    Internal gRPC servicer that adapts the PglAdapter to the PglRemote service.
    """

    def __init__(self, adapter: PglAdapter):
        self.adapter = adapter

    def ChoosePlan(self, request, context):
        if not request.plans:
            return pgl_rpc_pb2.ChoosePlanResponse(chosen_plan_index=0)

        # Parse JSON strings to Dicts
        parsed_plans = []
        for i, plan_str in enumerate(request.plans):
            try:
                parsed_plans.append(json.loads(plan_str))
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse plan at index {i}: {e}")
                parsed_plans.append({})

        try:
            chosen_index = self.adapter.choose_plan(parsed_plans)
        except Exception as e:
            logger.exception("Error in user adapter logic")
            context.abort(grpc.StatusCode.INTERNAL, f"Adapter error: {str(e)}")
            return

        # Validate return value
        if not (0 <= chosen_index < len(request.plans)):
            logger.error(
                f"Invalid plan index returned: {chosen_index}. Max: {len(request.plans) - 1}"
            )
            chosen_index = 0

        return pgl_rpc_pb2.ChoosePlanResponse(chosen_plan_index=chosen_index)


def run_server(
    adapter: PglAdapter, host: str = "0.0.0.0", port: int = 50051, max_workers: int = 10
):
    """
    Start the gRPC server hosting the given adapter.

    Args:
        adapter: An instance of a PglAdapter subclass.
        host: Host to bind to.
        port: Port to bind to.
        max_workers: Number of worker threads for the gRPC server.
    """
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=max_workers))
    servicer = PglRemoteAdapter(adapter)

    # This registration function is generated by grpc_tools
    pgl_rpc_pb2_grpc.add_PglRemoteServicer_to_server(servicer, server)

    address = f"{host}:{port}"
    server.add_insecure_port(address)

    print(f"PglServer starting on {address}...")
    server.start()
    try:
        server.wait_for_termination()
    except KeyboardInterrupt:
        server.stop(0)
